name: Build and Release

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: windows-latest

    permissions:
      contents: write

    outputs:
      new_version: ${{ steps.get_version.outputs.new_version }}
      commit_messages: ${{ steps.get_commits.outputs.commit_messages }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Checkout Submodules
        run: |
          git submodule sync --recursive
          git submodule update --init --recursive
        shell: pwsh

      - name: Set up .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0'

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Determine Version
        id: get_version
        run: |
          # Check if there are any tags
          $tags = git tag
          if ($tags -ne $null -and $tags.Count -gt 0) {
            # Get the latest tag and remove the leading 'v' if present
            $latestTag = (git describe --tags --abbrev=0 2>$null) -replace '^v', ''
            if (-not $latestTag) {
              $latestTag = "0.0.0"
            }
          } else {
            # Fallback to 0.0.0 if no tags exist
            $latestTag = "0.0.0"
          }

          # Ensure $latestTag is a string
          $latestTag = [string]$latestTag

          # Split the version into components
          $versionParts = $latestTag.Split('.')
          $major = [int]$versionParts[0]
          $minor = [int]$versionParts[1]
          $patch = [int]$versionParts[2]

          # Increment the patch version
          $patch++
          $newVersion = "$major.$minor.$patch"
          echo "new_version=$newVersion" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8
          echo "new_version=$newVersion" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Get Commit Messages
        id: get_commits
        run: |
          $latestTag = git describe --tags --abbrev=0 2>$null
          $commits = if ($latestTag) { git log ${latestTag}..HEAD --pretty=format:"- **%an**: %s" } else { git log --pretty=format:"- **%an**: %s" }
          echo "commit_messages<<EOF" >> $env:GITHUB_OUTPUT
          echo "$commits" >> $env:GITHUB_OUTPUT
          echo "EOF" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Configure Git User
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
        shell: pwsh

      - name: Install vpk as .NET Global Tool
        run: |
          dotnet tool install -g vpk
          $env:PATH += ";$env:USERPROFILE\.dotnet\tools"
        shell: pwsh

      - name: Install Frontend Dependencies
        working-directory: ./Frontend
        run: npm install
        shell: pwsh

      - name: Build Frontend
        working-directory: ./Frontend
        run: npm run build
        shell: pwsh

      - name: Move Frontend Build to Resources/wwwroot
        run: |
          $source = "./Frontend/dist"
          $destination = "./Resources/wwwroot"
          if (-Not (Test-Path -Path $destination)) { New-Item -ItemType Directory -Path $destination -Force }
          Remove-Item -Path "$destination\*" -Recurse -Force
          Copy-Item -Path "$source\*" -Destination $destination -Recurse -Force
        shell: pwsh

      - name: Build the App
        run: dotnet build --configuration Release
        shell: pwsh

      - name: Publish the App
        run: dotnet publish -c Release --self-contained -r win-x64 -o publish
        shell: pwsh

      - name: Package with vpk
        run: vpk pack -u ReCaps -v ${{ env.new_version }} -p ./publish -e ReCaps.exe -o ./output --packTitle "ReCaps"
        shell: pwsh

      - name: Create a Git Tag
        run: |
          git tag v${{ env.new_version }}
          git push origin v${{ env.new_version }}
        shell: pwsh

      - name: Upload Release Artifact
        uses: actions/upload-artifact@v3
        with:
          name: ReCaps
          path: ./output

  release:
    needs: build
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Download Build Artifact
        uses: actions/download-artifact@v3
        with:
          name: ReCaps

      - name: Generate Release Notes with OpenAI
        id: generate_release_notes
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Assign commit messages to a variable
          $commitMessages = "${{ needs.build.outputs.commit_messages }}"

          # Define the JSON payload as a single string with embedded commit messages
          $jsonPayload = @"
          {
            "model": "o1-preview",
            "messages": [
              {
                "role": "assistant",
                "content": [
                  {
                    "type": "text",
                    "text": "You are a helpful assistant specializing in formatting release notes for open-source applications, specifically games and clip recorders. Your task is to take raw update information and organize it into well-structured, clear, and professional release notes. Ensure that the release notes include only the following sections:\n\n- **New Features:** Describe any new functionalities or features added to the application.\n- **Improvements:** Highlight enhancements made to existing features or overall performance.\n- **Bug Fixes:** List any issues that have been resolved.\n\nUse Markdown formatting for readability and consistency. Maintain a user-friendly and engaging tone suitable for the applications community. Ensure that the release notes are concise and easy to understand for normal users, avoiding unnecessary technical jargon. Do not include any sections that are not part of the release, such as Installation Instructions, Version headers, Known Issues, or Thank You messages. Prioritize clarity and organization to help users quickly grasp the updates and changes in the new release."
                  }
                ]
              },
              {
                "role": "user",
                "content": [
                  {
                    "type": "text",
                    "text": "$commitMessages"
                  }
                ]
              }
            ]
          }
          "@

          # Convert the JSON payload string to a single-line string
          $body = $jsonPayload.Replace("`n", "").Replace("`r", "").Replace("`t", "").Trim()

          try {
              # Make the API call
              $response = Invoke-RestMethod -Uri "https://api.openai.com/v1/chat/completions" `
                  -Method POST `
                  -Headers @{
                      "Content-Type"  = "application/json"
                      "Authorization" = "Bearer $env:OPENAI_API_KEY"
                  } `
                  -Body $body

              # Check if the response contains choices
              if ($response.choices.Count -gt 0) {
                  $releaseNotes = $response.choices[0].message.content.Trim()
                  # Set the release notes as an output variable
                  echo "notes<<EOF" >> $GITHUB_OUTPUT
                  echo "$releaseNotes" >> $GITHUB_OUTPUT
                  echo "EOF" >> $GITHUB_OUTPUT
              } else {
                  throw "No choices returned in the OpenAI API response."
              }
          } catch {
              Write-Error "Failed to generate release notes: $_"
              # Optionally, set a default message or fail the workflow
              echo "notes<<EOF" >> $GITHUB_OUTPUT
              echo "Failed to generate release notes." >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              exit 1  # Exit with an error code to fail the step
          }
        shell: pwsh

      # **Debugging Step: Echo the Generated Release Notes**
      - name: Debug Release Notes
        run: |
          echo "Release Notes:"
          echo "${{ steps.generate_release_notes.outputs.notes }}"
        shell: pwsh

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.build.outputs.new_version }}
          release_name: Release v${{ needs.build.outputs.new_version }}
          body: ${{ steps.generate_release_notes.outputs.notes }}
          draft: false
          prerelease: false

      - name: List Files in Current Directory
        run: ls -la

      - name: Upload Setup File
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./ReCaps-win-Setup.exe
          asset_name: ReCaps-win-Setup.exe
          asset_content_type: application/octet-stream

      - name: Upload RELEASES File
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./RELEASES
          asset_name: RELEASES
          asset_content_type: text/plain

      - name: Upload releases.win.json
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./releases.win.json
          asset_name: releases.win.json
          asset_content_type: application/json

      - name: Upload assets.win.json
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./assets.win.json
          asset_name: assets.win.json
          asset_content_type: application/json

      - name: Upload nupkg
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./ReCaps-${{ needs.build.outputs.new_version }}-full.nupkg
          asset_name: ReCaps-${{ needs.build.outputs.new_version }}-full.nupkg
          asset_content_type: application/json
